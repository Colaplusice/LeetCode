## kmp算法

partial table 来记录前缀和后缀相等的字符串的个数
保留之前的信息，如果当前字符串匹配不成功，那就往后移动移动的是多少个字符呢，
根据partial index。table[index]的值是多少，说明有几个字符串和当前字符串是对称的。假如有两个
比如abcdefabe,两个ab前后对称，当后一个ab的下一个字符匹配不上时，整个字符串向后移动。
这两个ab间隔了多少个距离呢?当前的index值-1-2，假如e匹配不上了，e的index为8,
e的前一个字符b的对称个数为2，index为7，把当前字符串向后移动7-2,五个距离，前后两个ab就对上了。
可以继续开始匹配了。
提问1: 为什么要向后移动5个距离呢，难道移动1，2，3，4都是不行的吗？那些可能性都丢掉了是合理的吗？
答案是肯定的。你要是期望向后移动1个或者2个距离，就可以的话，我们来捋一捋。
首先，到了第8个才是不匹配的，可以推出字符串和子字符串的结构:
abcdefabe
abcdefabdwe....
第二个为字符串，第一个为子字符串，可以料到，他们的前七个都是相等的。如果向后移动一位可行的话，
要保证， 子字符串的第1位对的上字符串的第二位，依次类推...那么字符串的前7位和子字符都是同一个数字
如果移动两位可以对上的话，同样保持i+2==j,同时i==i+2,那么字符串必须两个为周期保持相等，比如
ababababc
abababababc..。

next数组的计算规则

